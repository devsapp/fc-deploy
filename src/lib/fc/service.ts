import { FunctionConfig } from './function';
import { LogConfig, AlicloudSls } from '../resource/sls';
import {
  RoleConfig,
  generateRamResourceName,
  AlicloudRam,
  isAutoGeneratedRole,
  PolicyStatementConfig,
  CustomPolicyConfig,
  extractRoleNameFromArn,
} from '../resource/ram';
import { VpcConfig, AlicloudVpc } from '../resource/vpc';
import { NasConfig, AlicloudNas } from '../resource/nas';
import * as definition from '../definition';
import { FC_DEFAULT_ROLE } from '../static';
import { ServerlessProfile, ICredentials } from '../profile';
import FcDeploy from './fc-deploy';
import { isAutoConfig } from '../definition';
import StdoutFormatter from '../component/stdout-formatter';
import * as core from '@serverless-devs/core';
import logger from '../../common/logger';

const { jsyaml: yaml, lodash: _ } = core;
export interface ServiceConfig {
  name: string;
  serviceName?: string;
  description?: string;
  internetAccess?: boolean;
  logConfig?: LogConfig | 'auto' | 'Auto';
  role?: string | RoleConfig;
  vpcConfig?: VpcConfig | 'auto' | 'Auto';
  nasConfig?: NasConfig | 'auto' | 'Auto';
  ossMountConfig?: {
    mountPoints: Array<{
      endpoint: string;
      bucketName: string;
      mountDir: string;
      readOnly?: boolean;
    }>;
  };
  tracingConfig?: 'Enable' | 'Disable';
  vpcBinding?: string[];
  import?: boolean;
  protect?: boolean;
}

export class FcService extends FcDeploy<ServiceConfig> {
  static extractFcRole(role) {
    const [, , , , path] = role.split(':');
    const [, roleName] = path.split('/');
    return roleName;
  }

  readonly hasFunctionAsyncConfig: boolean;
  readonly hasCustomContainerConfig: boolean;
  readonly hasVpcBindingConfig: boolean;
  readonly hasOssMountConfig: boolean;
  readonly runtime: string;
  hasAutoConfig: boolean;
  name: string;

  constructor(
    serviceConf: ServiceConfig,
    functionConf: FunctionConfig,
    serverlessProfile: ServerlessProfile,
    region: string,
    credentials: ICredentials,
    curPath?: string,
  ) {
    super(serviceConf, serverlessProfile, region, credentials, curPath);
    if (_.has(this.localConfig, 'vpcConfig') && _.has(this.localConfig.vpcConfig, 'vswitchIds')) {
      // vswitchIds -> vSwitchIds
      // @ts-ignore
      this.localConfig.vpcConfig.vSwitchIds = this.localConfig.vpcConfig.vswitchIds;
      // @ts-ignore
      delete this.localConfig.vpcConfig.vswitchIds;
    }
    this.hasCustomContainerConfig = _.has(functionConf, 'customContainerConfig');
    this.hasFunctionAsyncConfig = _.has(functionConf, 'asyncConfiguration');
    this.hasVpcBindingConfig = _.has(serviceConf, 'vpcBinding');
    this.hasOssMountConfig = _.has(serviceConf, 'ossMountConfig');
    this.runtime = _.get(functionConf, 'runtime');
    this.hasAutoConfig = false;
    this.name = serviceConf?.name;
  }

  async init(useLocal: boolean, useRemote: boolean, inputs): Promise<void> {
    const {
      service: { local, needInteract, diff },
    } = await this.plan(inputs, 'service');
    logger.debug(
      `service plan local::\n${JSON.stringify(
        local,
        null,
        2,
      )}needInteract:: ${needInteract}\ndiff::\n${diff}`,
    );
    this.localConfig = local;
    await this.initRemote('service', this.name);
    await this.initStateful();
    await this.initStatefulAutoConfig();
    await this.initLocal();
    await this.setUseRemote(
      this.name,
      'Service',
      useLocal,
      useRemote,
      needInteract,
      diff,
      undefined,
    );
  }

  genStateID(): string {
    return `${this.credentials.AccountID}-${this.region}-${this.name}`;
  }

  validateConfig(): void {
    if (_.isEmpty(this.localConfig)) {
      throw new Error('Please add serviceConfig in your s.yml/yaml');
    }
  }

  async generateServiceRole(): Promise<string> {
    const {
      role: serviceRole,
      vpcConfig,
      nasConfig,
      logConfig,
    } = this.localConfig || {};

    const accountID = this.credentials.AccountID;
    // 用户指定 'AliyunFCDefaultRole' 以外的任何 roleArn 时不做任何更新 Role 的处理
    if (_.isString(serviceRole) && !isAutoGeneratedRole(serviceRole)) {
      const roleName: string = extractRoleNameFromArn(serviceRole as string);
      logger.debug(StdoutFormatter.stdoutFormatter.using('role', `extracted name is ${roleName}`));
      return serviceRole as string;
    }

    const defaultRole = `acs:ram::${accountID}:role/aliyunfcdefaultrole`;
    const needAppendNetworkInterface = !_.isEmpty(vpcConfig) || !_.isEmpty(nasConfig);
    const alicloudRam = new AlicloudRam(
      this.serverlessProfile,
      this.credentials,
      this.region,
      this.curPath,
    );

    if (_.isEmpty(serviceRole) || isAutoGeneratedRole(serviceRole)) {
      const needAddPermission =
        this.hasFunctionAsyncConfig ||
        needAppendNetworkInterface ||
        this.hasCustomContainerConfig ||
        this.hasVpcBindingConfig ||
        this.hasOssMountConfig ||
        logConfig;

      logger.debug(`service config need add permission: ${needAddPermission}`);
      // service role 为空或者显示指定 roleName 为 AliyunFCDefaultRole
      if (needAddPermission || isAutoGeneratedRole(serviceRole)) {
        // Check role 是否存在，如果失败就输出授权地址让用户去控制台授权
        try {
          const roleExist = await alicloudRam.checkRoleExist({ arn: defaultRole });
          if (!roleExist) {
            this.logger.log('');
            logger.error(`It is detected that ${defaultRole} does not exist. If the deployment fails, please click https://dwz.onl/t/dkaQY to grant authorization`);
          }
          return defaultRole;
        } catch (ex) {
          if (ex.code === 'NoPermission') {
            this.logger.debug(`handler role no permission, error: ${ex}`);
            return defaultRole;
          }
          throw ex;
        }
      }
    }

    let roleDescription: string;
    const attachedPolicies = [];
    const roleName = (serviceRole as RoleConfig)?.name || generateRamResourceName('fcDeployDefaultRole-', this.localConfig?.name, accountID);
    logger.debug(`need create role ${roleName}`);

    if (!_.isEmpty((serviceRole as RoleConfig)?.policies)) {
      attachedPolicies.push(...(serviceRole as RoleConfig).policies);
    }

    if (this.hasFunctionAsyncConfig) {
      attachedPolicies.push('AliyunFCInvocationAccess');

      const mnsPolicyName = generateRamResourceName(
        'AliyunFcGeneratedMNSPolicy-',
        `${this.region}-${this.name}`,
        accountID,
      );
      const mnsPolicyStatement: PolicyStatementConfig = {
        Action: ['mns:SendMessage', 'mns:PublishMessage'],
        Resource: '*',
        Effect: 'Allow',
      };
      const mnsPolicy: CustomPolicyConfig = {
        name: mnsPolicyName,
        statement: [mnsPolicyStatement],
      };
      attachedPolicies.push(mnsPolicy);
    }

    if (needAppendNetworkInterface) {
      attachedPolicies.push('AliyunECSNetworkInterfaceManagementAccess');
    }

    if (this.hasCustomContainerConfig) {
      attachedPolicies.push('AliyunContainerRegistryReadOnlyAccess');
    }

    if (this.hasOssMountConfig) {
      attachedPolicies.push('AliyunOSSFullAccess');
    }

    if (definition.isAutoConfig(logConfig)) {
      attachedPolicies.push('AliyunLogFullAccess');
    } else if ((logConfig as LogConfig)?.project && (logConfig as LogConfig)?.logstore) {
      const logPolicyName = generateRamResourceName(
        'fcDeployDefaultLogPolicy-',
        `${this.region}-${this.name}`,
        accountID,
      );
      const logPolicyStatement: PolicyStatementConfig = {
        Action: ['log:PostLogStoreLogs'],
        Resource: `acs:log:*:*:project/${(logConfig as LogConfig)?.project}/logstore/${(logConfig as LogConfig).logstore}`,
        Effect: 'Allow',
      };
      const logPolicy: CustomPolicyConfig = {
        name: logPolicyName,
        statement: [logPolicyStatement],
      };
      attachedPolicies.push(logPolicy);
    }

    if (_.isEmpty(attachedPolicies)) {
      return undefined;
    }

    this.hasAutoConfig = true;
    const assumeRolePolicy = [
      {
        Action: 'sts:AssumeRole',
        Effect: 'Allow',
        Principal: {
          Service: ['fc.aliyuncs.com'],
        },
      },
    ];
    try {
      const roleArn = await alicloudRam.makeRole(
        roleName,
        this.name,
        undefined,
        roleDescription,
        undefined,
        assumeRolePolicy,
        attachedPolicies,
      );
      return roleArn;
    } catch (ex) {
      // UnauthorizedError
      if (ex.code === 'NoPermission') {
        this.logger.debug(`handler role no permission, error: ${ex}`);
        return defaultRole;
      }
      throw ex;
    }
  }

  async setStatefulAutoConfig(): Promise<void> {
    const stateID: string = this.genStateID();
    const state: any = await this.getState();
    const statefulAutoConfig: any = state?.statefulAutoConfig || {};
    if (
      !this.useRemote &&
      this.statefulConfig?.nasConfig &&
      definition.isAutoConfig(this.localConfig?.nasConfig)
    ) {
      Object.assign(statefulAutoConfig, {
        nasConfig: this.statefulConfig.nasConfig,
      });
    }
    if (
      !this.useRemote &&
      this.statefulConfig?.vpcConfig &&
      (definition.isAutoConfig(this.localConfig?.vpcConfig) ||
        definition.isAutoConfig(this.localConfig?.nasConfig))
    ) {
      Object.assign(statefulAutoConfig, {
        vpcConfig: this.statefulConfig.vpcConfig,
      });
    }
    if (
      !this.useRemote &&
      this.statefulConfig?.logConfig &&
      definition.isAutoConfig(this.localConfig?.logConfig)
    ) {
      Object.assign(statefulAutoConfig, {
        logConfig: this.statefulConfig.logConfig,
      });
    }
    if (!this.useRemote && this.statefulConfig?.role && _.isEmpty(this.localConfig?.role)) {
      Object.assign(statefulAutoConfig, {
        role: this.statefulConfig.role,
      });
    }
    if (!_.isEmpty(statefulAutoConfig)) {
      this.logger.debug(`Set stateful auto config of ${statefulAutoConfig} into state.`);
      await this.setKVInState(stateID, 'statefulAutoConfig', statefulAutoConfig);
    }
  }

  async generateServiceLog(): Promise<LogConfig> {
    const { logConfig } = this.localConfig;
    if (_.isEmpty(logConfig)) {
      return undefined;
    }
    let resolvedLogConfig: LogConfig;
    if (_.isString(logConfig)) {
      if (definition.isAutoConfig(logConfig)) {
        this.hasAutoConfig = true;
        const aliyunSls = new AlicloudSls(this.serverlessProfile, this.credentials, this.region);
        this.logger.debug(
          StdoutFormatter.stdoutFormatter.using(
            'logConfig: auto',
            'fc will try to generate default sls project',
          ),
        );
        resolvedLogConfig = await aliyunSls.createDefaultSls(this.name);
        this.logger.debug(
          `Generated logConfig: \n${yaml.dump(resolvedLogConfig, {
            styles: {
              '!!null': 'canonical', // dump null as ~
            },
            sortKeys: true, // sort object keys
          })}`,
        );
      } else {
        throw new Error('logConfig only support auto/Auto when set to string.');
      }
    } else {
      if (!((logConfig as LogConfig)?.project && (logConfig as LogConfig)?.logstore)) {
        throw new Error('logstore and project must both exist in logConfig');
      }
      resolvedLogConfig = {
        project: (logConfig as LogConfig).project,
        logstore: (logConfig as LogConfig).logstore,
        enableRequestMetrics: (logConfig as LogConfig).enableRequestMetrics || false,
        enableInstanceMetrics: (logConfig as LogConfig).enableInstanceMetrics || false,
        logBeginRule: (logConfig as LogConfig).logBeginRule,
      };
    }
    return resolvedLogConfig;
  }

  async generateServiceVpc(isNasAuto: boolean): Promise<VpcConfig> {
    const { vpcConfig } = this.localConfig;
    if ((_.isNil(vpcConfig) && isNasAuto) || _.isString(vpcConfig)) {
      if (_.isString(vpcConfig)) {
        if (!definition.isAutoConfig(vpcConfig)) {
          throw new Error('vpcConfig only support auto/Auto when set to string.');
        }
      }
      this.hasAutoConfig = true;
      // vpc auto
      this.logger.debug(
        StdoutFormatter.stdoutFormatter.using(
          'vpcConfig: auto',
          'fc will try to generate related vpc resources automatically',
        ),
      );
      const alicloudVpc = new AlicloudVpc(
        this.serverlessProfile,
        this.credentials,
        this.region,
        this.curPath,
      );
      const vpcDeployRes = await alicloudVpc.createDefaultVpc(this.name);
      this.logger.debug(
        `Generated vpcConfig: \n${yaml.dump(vpcDeployRes, {
          styles: {
            '!!null': 'canonical', // dump null as ~
          },
          sortKeys: true, // sort object keys
        })}`,
      );
      return {
        vpcId: vpcDeployRes.vpcId,
        securityGroupId: vpcDeployRes.securityGroupId,
        vSwitchIds: [vpcDeployRes.vSwitchId],
      };
    }
    return vpcConfig as VpcConfig;
  }

  async generateServiceNas(
    vpcConfig: VpcConfig,
    roleArn: string,
    assumeYes?: boolean,
  ): Promise<NasConfig> {
    let { nasConfig } = this.localConfig;
    const alicloudNas = new AlicloudNas(
      this.serverlessProfile,
      this.credentials,
      this.region,
      this.curPath,
    );
    if (_.isString(nasConfig)) {
      if (definition.isAutoConfig(nasConfig)) {
        this.hasAutoConfig = true;
        this.logger.debug(
          StdoutFormatter.stdoutFormatter.using(
            'nasConfig: auto',
            'fc will try to generate related nas file system automatically',
          ),
        );
        try {
          nasConfig = await alicloudNas.createDefaultNas(
            this.name,
            vpcConfig,
            `/${this.name}`,
            roleArn,
            assumeYes,
            this.runtime,
          );
          this.logger.debug(
            `Generated nasConfig: \n${yaml.dump(nasConfig, {
              styles: {
                '!!null': 'canonical', // dump null as ~
              },
              sortKeys: true, // sort object keys
            })}`,
          );
        } catch (ex) {
          if (
            (ex?.message || '').includes(
              'Your account does not open Nas Service yet or balance is insufficient',
            )
          ) {
            ex.message = `${ex.message}\nOpen: https://nasnext.console.aliyun.com/cn-chengdu/filesystem`;
          }
          throw ex;
        }
      } else {
        throw new Error('nasConfig only support auto/Auto when set to string.');
      }
    }

    const abnormalAssociation = await alicloudNas.getInvalidMountAssociationVpcId(vpcConfig.vpcId, nasConfig as NasConfig);
    if (abnormalAssociation) {
      throw new core.CatchableError(`The mount point ${abnormalAssociation} and vpcId ${vpcConfig.vpcId} do not match`);
    }

    return nasConfig as NasConfig;
  }

  async makeService(assumeYes?: boolean): Promise<ServiceConfig> {
    if (this.useRemote) {
      this.statefulConfig = _.cloneDeep(this.remoteConfig);
      this.upgradeStatefulConfig();
      return this.remoteConfig;
    }
    if (_.isEmpty(this.localConfig)) {
      this.statefulConfig = null;
      return null;
    }
    const resolvedServiceConf: ServiceConfig = {
      name: this.name,
    };

    if (!_.isNil(this.localConfig.tracingConfig)) {
      Object.assign(resolvedServiceConf, { tracingConfig: this.localConfig.tracingConfig });
    }

    if (!_.isEmpty(this.localConfig.vpcBinding)) {
      Object.assign(resolvedServiceConf, { vpcBinding: this.localConfig.vpcBinding });
    }

    if (!_.isNil(this.localConfig.description)) {
      Object.assign(resolvedServiceConf, { description: this.localConfig.description });
    }

    if (!_.isNil(this.localConfig.internetAccess)) {
      Object.assign(resolvedServiceConf, { internetAccess: this.localConfig.internetAccess });
    }
    const role = await this.generateServiceRole();
    if (!_.isEmpty(role)) {
      Object.assign(resolvedServiceConf, { role });
    }
    if (!_.isEmpty(this.localConfig.logConfig)) {
      const resolvedLogConfig = await this.generateServiceLog();
      Object.assign(resolvedServiceConf, { logConfig: resolvedLogConfig });
    }
    const { nasConfig } = this.localConfig;
    const isNasAuto = definition.isAutoConfig(nasConfig);

    if (!_.isEmpty(this.localConfig.vpcConfig) || isNasAuto) {
      // vpc
      const resolvedVpcConfig = await this.generateServiceVpc(isNasAuto);
      Object.assign(resolvedServiceConf, { vpcConfig: resolvedVpcConfig });
    }
    if (!_.isEmpty(this.localConfig.nasConfig)) {
      // nas
      const resolvedNasConfig = await this.generateServiceNas(
        // @ts-ignore
        resolvedServiceConf?.vpcConfig,
        resolvedServiceConf?.role,
        assumeYes,
      );
      Object.assign(resolvedServiceConf, { nasConfig: resolvedNasConfig });
    }

    if (!_.isEmpty(this.localConfig.ossMountConfig)) {
      Object.assign(resolvedServiceConf, { ossMountConfig: this.localConfig.ossMountConfig });
    }
    if (this.existOnline) {
      Object.assign(resolvedServiceConf, {
        import: true,
        protect: false,
      });
    }
    return resolvedServiceConf;
  }

  async initLocal(): Promise<void> {
    this.validateConfig();
    await this.initLocalConfig();
    this.logger.debug(
      `local service config is: ${JSON.stringify(this.localConfig, null, '  ')} after init.`,
    );
  }

  private async initLocalConfig(): Promise<void> {
    if (_.isEmpty(this.statefulAutoConfig) && _.isEmpty(this.remoteConfig)) {
      return;
    }
    const { logConfig, vpcConfig, role } = this.remoteConfig || {};
    const resolvedAutoConfigInState: any = this.statefulAutoConfig || {};
    // auto 优先使用线上配置，不存在时再使用缓存配置
    const logConfigAuto = isAutoConfig(this.localConfig.logConfig);
    if (logConfigAuto) {
      // @ts-ignore: check online config
      if (logConfig?.project) {
        this.localConfig.logConfig = logConfig;
      } else if (resolvedAutoConfigInState?.logConfig?.project) {
        this.localConfig.logConfig = resolvedAutoConfigInState.logConfig;
      }
    }

    const vpcConfigAuto =
      isAutoConfig(this.localConfig.vpcConfig) ||
      (isAutoConfig(this.localConfig.nasConfig) && _.isEmpty(this.localConfig.vpcConfig));
    if (vpcConfigAuto) {
      // @ts-ignore: check online config
      if (vpcConfig?.vpcId) {
        this.localConfig.vpcConfig = vpcConfig;
      } else if (resolvedAutoConfigInState?.vpcConfig?.vpcId) {
        this.localConfig.vpcConfig = resolvedAutoConfigInState.vpcConfig;
      } else {
        this.localConfig.vpcConfig = 'auto';
      }
    }
    const nasConfigAuto = isAutoConfig(this.localConfig.nasConfig);

    const roleAuto = isAutoConfig(this.localConfig.role);
    // 存在需要角色的 auto 配置
    if (
      this.hasFunctionAsyncConfig ||
      logConfigAuto ||
      vpcConfigAuto ||
      nasConfigAuto ||
      roleAuto
    ) {
      // 如果角色为 auto 或者没有配置角色，则复用配置
      if (roleAuto || _.isEmpty(this.localConfig.role)) {
        if (!_.isEmpty(role)) {
          this.localConfig.role = role;
        } else if (!_.isEmpty(resolvedAutoConfigInState.role)) {
          this.localConfig.role = resolvedAutoConfigInState.role;
        } else {
          this.localConfig.role = _.isEmpty(this.localConfig.role)
            ? this.localConfig.role
            : FC_DEFAULT_ROLE;
        }
      }
    }

    if (this.existOnline) {
      Object.assign(this.localConfig, {
        import: true,
        protect: false,
      });
    }
  }
}
